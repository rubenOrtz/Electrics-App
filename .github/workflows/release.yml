name: ðŸš€ Production Release

on:
  workflow_dispatch:
  pull_request:
    branches: [main]
    paths:
      - 'lib/**'
      - 'test/**'
      - 'pubspec.yaml'
      - '.github/workflows/release.yml'

permissions:
  contents: write

jobs:
  # -----------------------------------------------------------------
  # JOB 1: QUALITY GATE & BUILD
  # -----------------------------------------------------------------
  verify-and-build:
    name: ðŸ›¡ï¸ Verify, Build & Package
    runs-on: ubuntu-latest
    outputs:
      app_name: ${{ steps.meta.outputs.APP_NAME }}
      version: ${{ steps.meta.outputs.VERSION }}
      build_number: ${{ steps.meta.outputs.BUILD_NUMBER }}
      is_release: ${{ github.event_name == 'workflow_dispatch' }}
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1. STRICT VERSION VALIDATION
      - name: ðŸ§  Extract & Validate Metadata
        id: meta
        uses: mikefarah/yq@master
        with:
          cmd: |
            APP_NAME=$(yq '.name' pubspec.yaml)
            VERSION_FULL=$(yq '.version' pubspec.yaml)
            
            # STRICT REGEX VALIDATION: Must be x.y.z+n
            if [[ ! "$VERSION_FULL" =~ ^[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+$ ]]; then
              echo "â›” ERROR: Invalid version format in pubspec.yaml"
              echo "   Found: '$VERSION_FULL'"
              echo "   Required format: x.y.z+n (e.g., 1.0.0+1)"
              exit 1
            fi
            
            # Extract components AFTER validation
            VERSION_BASE=${VERSION_FULL%+*}
            BUILD_NUMBER=${VERSION_FULL#*+}
            
            echo "âœ… Validated: $APP_NAME v$VERSION_BASE (Build: $BUILD_NUMBER)"
            
            # Export for subsequent steps
            echo "APP_NAME=$APP_NAME" >> $GITHUB_OUTPUT
            echo "VERSION=v$VERSION_BASE" >> $GITHUB_OUTPUT
            echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      # 2. VERSION INCREMENT CHECK
      - name: ðŸ” Verify Version Was Bumped
        if: github.event_name == 'workflow_dispatch'
        env:
          VERSION: ${{ steps.meta.outputs.VERSION }}
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          
          if [[ "$VERSION" == "$LATEST_TAG" ]]; then
            echo "â›” ERROR: Version in pubspec.yaml was not bumped!"
            echo "   Current version: $VERSION"
            echo "   Latest tag: $LATEST_TAG"
            echo "   Action: Increment version in pubspec.yaml before releasing"
            exit 1
          fi
          
          echo "âœ… Version bumped from $LATEST_TAG to $VERSION"

      # 3. GIT TAG COLLISION CHECK
      - name: ðŸ›‘ Check Tag Uniqueness
        if: github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ steps.meta.outputs.VERSION }}
        run: |
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "â›” ERROR: Git tag '$TAG' already exists"
            echo "   Action: Bump version in pubspec.yaml before releasing"
            exit 1
          fi
          echo "âœ… Tag '$TAG' is available"

      - name: â˜• Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'
          cache: 'gradle'

      - name: ðŸ¦ Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true

      - name: ðŸ“¦ Install Dependencies
        run: flutter pub get

      # 4. CODE GENERATION (Modern Dart Command)
      - name: ðŸ—ï¸ Generate Code
        run: dart run build_runner build --delete-conflicting-outputs

      # 5. CONFIG GENERATION - Using Individual Secrets (Not Monolithic JSON)
      - name: ðŸ” Generate Environment Config
        env:
          API_KEY: ${{ secrets.API_KEY }}
          BASE_URL: ${{ secrets.BASE_URL }}
        run: |
          # Validate secrets exist
          if [[ -z "$API_KEY" ]]; then
            echo "â›” CRITICAL: API_KEY secret is missing!"
            exit 1
          fi
          
          if [[ -z "$BASE_URL" ]]; then
            echo "â›” CRITICAL: BASE_URL secret is missing!"
            exit 1
          fi
          
          # Generate config from template
          # This allows CI to inject values without knowing the full schema
          cat > env.json << EOF
          {
            "API_KEY": "$API_KEY",
            "BASE_URL": "$BASE_URL"
          }
          EOF
          
          # Validate generated JSON
          jq empty env.json || {
            echo "â›” ERROR: Generated env.json is malformed"
            exit 1
          }
          
          echo "âœ… Environment config generated with $(jq 'keys | length' env.json) keys"

      - name: ðŸ•µï¸ Static Analysis
        run: flutter analyze --fatal-infos --fatal-warnings

      - name: ðŸ§ª Unit Tests
        run: flutter test

      # 6. ANDROID SIGNING SETUP (FIXED: Correct Path Resolution)
      - name: ðŸ” Configure Android Signing
        if: github.event_name == 'workflow_dispatch'
        run: |
          # FIX: Place keystore in android/app/ directory where Gradle expects it
          # Line 11 in build.gradle.kts: rootProject.file("key.properties")
          # Line 45 in build.gradle.kts: file(it) - resolves relative to android/
          
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 --decode > android/app/upload-keystore.jks
          
          # Create key.properties in android/ directory (rootProject location)
          # storeFile path is relative to android/, so we reference app/upload-keystore.jks
          cat > android/key.properties << EOF
          storePassword=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          keyPassword=${{ secrets.ANDROID_KEY_PASSWORD }}
          keyAlias=${{ secrets.ANDROID_KEY_ALIAS }}
          storeFile=app/upload-keystore.jks
          EOF
          
          echo "âœ… Keystore: android/app/upload-keystore.jks"
          echo "âœ… Properties: android/key.properties"

      - name: ðŸ—ï¸ Build Production AAB
        if: github.event_name == 'workflow_dispatch'
        run: |
          flutter build appbundle --release \
            --obfuscate \
            --split-debug-info=build/app/outputs/symbols \
            --dart-define-from-file=env.json

      - name: ðŸ“¦ Package Debug Symbols
        if: github.event_name == 'workflow_dispatch'
        run: |
          cd build/app/outputs/symbols
          zip -r symbols.zip .
          mv symbols.zip ../../../debug-symbols.zip
          cd ../../../../

      - name: ðŸ“¤ Upload Release Artifacts
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: release-bundle
          path: |
            build/app/outputs/bundle/release/app-release.aab
            build/debug-symbols.zip
          retention-days: 1

  # -----------------------------------------------------------------
  # JOB 2: PUBLISH RELEASE (Only on manual dispatch)
  # -----------------------------------------------------------------
  publish-release:
    name: ðŸ“¦ Create GitHub Release
    needs: [verify-and-build]
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ðŸ“¥ Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-bundle
          path: artifacts

      - name: ðŸ” Verify Downloaded Artifacts
        run: |
          echo "ðŸ“¦ Artifact contents:"
          ls -lhR artifacts/
          
          # Verify expected files exist
          if [[ ! -f "artifacts/app-release.aab" ]]; then
            echo "â›” ERROR: app-release.aab not found in artifacts"
            exit 1
          fi
          
          if [[ ! -f "artifacts/debug-symbols.zip" ]]; then
            echo "â›” ERROR: debug-symbols.zip not found in artifacts"
            exit 1
          fi
          
          echo "âœ… All required artifacts present"

      - name: ðŸ·ï¸ Prepare Release Assets
        env:
          APP_NAME: ${{ needs.verify-and-build.outputs.app_name }}
          VERSION: ${{ needs.verify-and-build.outputs.version }}
          BUILD: ${{ needs.verify-and-build.outputs.build_number }}
        run: |
          # Move files to current directory with semantic naming
          mv artifacts/app-release.aab ${APP_NAME}-${VERSION}-build${BUILD}.aab
          mv artifacts/debug-symbols.zip debug-symbols-${VERSION}.zip
          
          # Verify renamed files
          ls -lh *.aab *.zip
          echo "âœ… Assets prepared for release"

      # CRITICAL: Tag creation happens AFTER successful build
      - name: ðŸŽ‰ Create Release & Tag
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.verify-and-build.outputs.version }}
          name: "Release ${{ needs.verify-and-build.outputs.version }}"
          body: |
            ## ðŸš€ Production Release ${{ needs.verify-and-build.outputs.version }}
            
            **Build Number:** ${{ needs.verify-and-build.outputs.build_number }}
            **App:** ${{ needs.verify-and-build.outputs.app_name }}
            
            ### ðŸ“¦ Downloads
            - **Android App Bundle (AAB):** `${{ needs.verify-and-build.outputs.app_name }}-${{ needs.verify-and-build.outputs.version }}-build${{ needs.verify-and-build.outputs.build_number }}.aab`
            - **Debug Symbols:** `debug-symbols-${{ needs.verify-and-build.outputs.version }}.zip`
            
            ### âœ… Quality Gates Passed
            - âœ… Static Analysis (`flutter analyze`)
            - âœ… Unit Tests (`flutter test`)
            - âœ… Code Generation (`build_runner`)
            - âœ… Version validation (strict semver)
          files: |
            *.aab
            *.zip
          draft: true
          make_latest: true
          generate_release_notes: true
          fail_on_unmatched_files: true